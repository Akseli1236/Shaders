{
 "ver": "0.1",
 "info": {
  "id": "wXBfWV",
  "date": "0",
  "viewed": 0,
  "name": "Ex6, Task 3",
  "description": "tag",
  "likes": 0,
  "published": "Private",
  "usePreview": 0,
  "tags": [
   "tag"
  ],
  "hasliked": 0,
  "parentid": "",
  "parentname": ""
 },
 "renderpass": [
  {
   "inputs": [
    {
     "id": "XdX3Rn",
     "filepath": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg",
     "type": "texture",
     "channel": 0,
     "sampler": {
      "filter": "linear",
      "wrap": "repeat",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    },
    {
     "id": "4dX3Rn",
     "filepath": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg",
     "type": "texture",
     "channel": 1,
     "sampler": {
      "filter": "linear",
      "wrap": "repeat",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    },
    {
     "id": "XdXGzr",
     "filepath": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg",
     "type": "texture",
     "channel": 2,
     "sampler": {
      "filter": "linear",
      "wrap": "repeat",
      "vflip": "true",
      "srgb": "false",
      "internal": "byte"
     },
     "published": 1
    }
   ],
   "outputs": [
    {
     "id": "4dfGRr",
     "channel": 0
    }
   ],
   "code": "#define PI 3.14159265359\n\nint indices[30] = int[30](0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 0, 15, 1, 3, 16, 4, 6, 17, 7, 9, 18, 10, 12, 19, 13);\n\nvec3 positions[20] = vec3[20](vec3(-1.000000, 2.000000, 1.000000), vec3(-1.000000, 0.000000, -1.000000), vec3(-1.000000, 0.000000, 1.000000), vec3(-1.000000, 2.000000, -1.000000), vec3(1.000000, 0.000000, -1.000000), vec3(-1.000000, 0.000000, -1.000000), vec3(1.000000, 2.000000, -1.000000), vec3(1.000000, 0.000000, 1.000000), vec3(1.000000, 0.000000, -1.000000), vec3(1.000000, 2.000000, 1.000000), vec3(-1.000000, 0.000000, 1.000000), vec3(1.000000, 0.000000, 1.000000), vec3(-1.000000, 2.000000, -1.000000), vec3(1.000000, 2.000000, 1.000000), vec3(1.000000, 2.000000, -1.000000), vec3(-1.000000, 2.000000, -1.000000), vec3(1.000000, 2.000000, -1.000000), vec3(1.000000, 2.000000, 1.000000), vec3(-1.000000, 2.000000, 1.000000), vec3(-1.000000, 2.000000, 1.000000));\n\nvec2 texcoords[20] = vec2[20](vec2(0.625000, 0.000000), vec2(0.375000, 0.250000), vec2(0.375000, 0.000000), vec2(0.625000, 0.250000), vec2(0.375000, 0.500000), vec2(0.375000, 0.250000), vec2(0.625000, 0.500000), vec2(0.375000, 0.750000), vec2(0.375000, 0.500000), vec2(0.625000, 0.750000), vec2(0.375000, 1.000000), vec2(0.375000, 0.750000), vec2(0.875000, 0.500000), vec2(0.625000, 0.750000), vec2(0.625000, 0.500000), vec2(0.625000, 0.250000), vec2(0.625000, 0.500000), vec2(0.625000, 0.750000), vec2(0.625000, 1.000000), vec2(0.875000, 0.750000));\n\nmat4 translate(vec3 t) {\n    return mat4(\n        1,0,0,0,\n        0,1,0,0,\n        0,0,1,0,\n        t.x, t.y, t.z, 1\n    );\n}\n\nmat4 scale(vec3 s) {\n    return mat4(\n        s.x,0,0,0,\n        0,s.y,0,0,\n        0,0,s.z,0,\n        0,0,0,1\n    );\n}\n\nmat4 rotateX(float deg) {\n    float r = radians(deg);\n    float c = cos(r), s = sin(r);\n    return mat4(\n        1,0,0,0,\n        0,c,s,0,\n        0,-s,c,0,\n        0,0,0,1\n    );\n}\nmat4 rotateY(float deg) {\n    float r = radians(deg);\n    float c = cos(r), s = sin(r);\n    return mat4(\n        c,0,-s,0,\n        0,1,0,0,\n        s,0,c,0,\n        0,0,0,1\n    );\n}\nmat4 rotateZ(float deg) {\n    float r = radians(deg);\n    float c = cos(r), s = sin(r);\n    return mat4(\n        c,s,0,0,\n        -s,c,0,0,\n        0,0,1,0,\n        0,0,0,1\n    );\n}\n\n// Multiply translation matrix, rotation matrices and scale matrix\n// to get transformation matrix\nmat4 makeTRS(vec3 t, vec3 r, vec3 s) {\n    return translate(t) * rotateZ(r.z) * rotateY(r.y) * rotateX(r.x) * scale(s);\n}\n\nvec3 toLinear(vec3 c) { return pow(c, vec3(2.2)); }\nvec3 toSRGB(vec3 c)   { return pow(c, vec3(1.0 / 2.2)); }\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / (iResolution.y);\n\n    vec3 cameraOrigin = vec3(0.33, 3.23, 15);\n    vec3 lookingAt = vec3(1.0, 4.0, 1.0);\n    vec3 upVec = vec3(0.0, 1.0, 0.0);\n    \n    float radfov = (60.0 / 2.0) * PI / 180.0;\n    float focalLength = 1.0 / tan(radfov);\n    \n    vec3 Z = normalize(cameraOrigin - lookingAt);\n    vec3 X = normalize(cross(upVec, Z));\n    vec3 Y = cross(Z, X);\n    \n    mat3 R = mat3(X, Y, Z);\n    \n    vec3 direction = R*normalize(vec3(uv, -0.5*focalLength));\n    \n    vec3 position[3] = vec3[3](vec3(2.0, 0.0, 1.0), vec3(-2.0, 0.0, 0.0), vec3(0.0, 4.0, 4.0));\n    vec3 rotation[3] = vec3[3](vec3(0.0, -29.2, 0.0), vec3(0.0, 38.5, 0.0), vec3(-90.0, 0.0, 0.0));\n    vec3 scale[3] = vec3[3](vec3(1.0, 1.0, 1.0), vec3(1.0, 2.0, 1.0), vec3(4.0, 4.0, 4.0));\n    \n\n    vec3 planeColor = vec3(0.0, 0.0, 0.0);\n    float tMin = 1e20; // Closest hit\n    \n    \n    \n    for (int n = 0; n < 3; ++n){\n    \n        mat4 boxTRS = makeTRS(position[n], rotation[n], scale[n]);\n        \n        for (int i=0; i < indices.length(); i += 3){\n            \n            \n            //Multiply each vertex with the TRS-matrix\n            vec3 v0 = (boxTRS * vec4(positions[indices[i + 0]], 1.0)).xyz;\n            vec3 v1 = (boxTRS * vec4(positions[indices[i + 1]], 1.0)).xyz;\n            vec3 v2 = (boxTRS * vec4(positions[indices[i + 2]], 1.0)).xyz;\n\n        \n            // e1 = v1-v0 and e2 = v2-v0\n            vec3 N = normalize(cross(v1-v0,v2-v0));\n\n            // N * P = D\n            // D = N * P\n            float D = dot(N, v0);\n\n            // N * P = D and P = origin + t*direction\n            // N * (origin + t*direction) = D\n            // N * origin + N * t*direction = D\n            // t = (D - N * origin) / N * direction\n\n            if (abs(dot(N, direction)) > 1e-06) {\n            float t = (D-dot(N, cameraOrigin)) / dot(N, direction);\n\n            if (t > 0.0 && t < tMin){\n                vec3 P = cameraOrigin + t*direction;\n                \n                vec3 V = normalize(cameraOrigin - P);\n                float cosTheta = abs(dot(N, V));\n\n\n                // Set the A or v0 to origon and calculate vectors from\n                // A to B, A to C and A to P (point in triangle)\n\n                vec3 AB = v1-v0;\n                vec3 AC = v2-v0;\n                vec3 AP = P-v0;\n\n                // P = A + v*AB + w*AC\n                // AP = v*AB + w*AC\n                // Using dot product we can project this equation to AB and AC\n                // dot(AP,AB) = v*dot(AB,AB) + w*(AC,AB)\n                // dot(AP,AC) = v*dot(AB,AC) + w*(AC,AC)\n                // From these we can solve v and w\n\n                float d00 = dot(AB, AB);\n                float d01 = dot(AB, AC);\n                float d11 = dot(AC, AC);\n                float d20 = dot(AP, AB);\n                float d21 = dot(AP, AC);\n\n                // From the equation above ChatGPT provides solutions for v and w\n                // And we also know that u = 1 - v - w\n\n                float denom = d00 * d11 - d01 * d01;\n\n                float v = (d11 * d20 - d01 * d21) / denom;\n                float w = (d00 * d21 - d01 * d20) / denom;\n                float u = 1.0 - v - w;\n\n                if (v < 0.0 || u < 0.0 || w < 0.0) continue;\n\n                vec2 n0 = texcoords[indices[i + 0]];\n                vec2 n1 = texcoords[indices[i + 1]];\n                vec2 n2 = texcoords[indices[i + 2]];\n\n                vec2 NText = n0 * u + n1 * v + n2 * w;\n                \n                vec4 tex = vec4(0.0);\n                \n                if (n == 0){\n                    tex = texture(iChannel0, NText);\n                }\n                if (n == 1){\n                    tex = texture(iChannel1, NText);\n                }\n                if (n == 2){\n                    tex = texture(iChannel2, NText);\n                }\n                \n                vec3 linearColor = toLinear(tex.rgb);\n                vec3 shaded = linearColor * cosTheta;\n                vec3 finalColor = toSRGB(shaded);\n                \n                planeColor = finalColor;\n                tMin = t;\n\n             }       \n        }\n        }\n    }\n    \n    // Output to screen\n    fragColor = vec4(planeColor,1.0);\n}",
   "name": "Image",
   "description": "",
   "type": "image"
  }
 ]
}