{
 "ver": "0.1",
 "info": {
  "id": "wfKcRh",
  "date": "0",
  "viewed": 0,
  "name": "Ex9, Task 2",
  "description": "tag",
  "likes": 0,
  "published": "Private",
  "usePreview": 0,
  "tags": [
   "tag"
  ],
  "hasliked": 0,
  "parentid": "",
  "parentname": ""
 },
 "renderpass": [
  {
   "inputs": [],
   "outputs": [
    {
     "id": "4dfGRr",
     "channel": 0
    }
   ],
   "code": "#define PI 3.14159265359\n\nint indices[108] = int[108](0, 1, 2, 1, 3, 2, 4, 5, 6, 5, 7, 6, 2, 3, 7, 2, 7, 5, 8, 9, 10, 9, 11, 10, 12, 13, 14, 12, 14, 15, 16, 17, 18, 17, 19, 18, 20, 18, 21, 18, 19, 21, 22, 16, 20, 16, 18, 20, 23, 17, 22, 17, 16, 22, 21, 19, 23, 19, 17, 23, 23, 17, 22, 17, 16, 22, 24, 25, 26, 25, 27, 26, 28, 24, 29, 24, 26, 29, 29, 26, 30, 26, 27, 30, 30, 27, 31, 27, 25, 31, 31, 25, 28, 25, 24, 28, 31, 25, 28, 25, 24, 28, 32, 33, 34, 33, 35, 34);\n\nvec3 positions[36] = vec3[36](vec3(-1.010000, 0.000000, 0.990000), vec3(1.000000, 0.000000, 0.990000), vec3(-0.990000, 0.000000, -1.040000), vec3(1.000000, 0.000000, -1.040000), vec3(-1.020000, 1.990000, 0.990000), vec3(-1.020000, 1.990000, -1.040000), vec3(1.000000, 1.990000, 0.990000), vec3(1.000000, 1.990000, -1.040000), vec3(1.000000, 0.000000, -1.040000), vec3(1.000000, 0.000000, 0.990000), vec3(1.000000, 1.990000, -1.040000), vec3(1.000000, 1.990000, 0.990000), vec3(-1.010000, 0.000000, 0.990000), vec3(-0.990000, 0.000000, -1.040000), vec3(-1.020000, 1.990000, -1.040000), vec3(-1.020000, 1.990000, 0.990000), vec3(0.530000, 0.600000, 0.750000), vec3(0.700000, 0.600000, 0.170000), vec3(-0.050000, 0.600000, 0.570000), vec3(0.130000, 0.600000, 0.000000), vec3(-0.050000, 0.000000, 0.570000), vec3(0.130000, 0.000000, 0.000000), vec3(0.530000, 0.000000, 0.750000), vec3(0.700000, 0.000000, 0.170000), vec3(-0.530000, 1.200000, 0.090000), vec3(0.040000, 1.200000, -0.090000), vec3(-0.710000, 1.200000, -0.490000), vec3(-0.140000, 1.200000, -0.670000), vec3(-0.530000, 0.000000, 0.090000), vec3(-0.710000, 0.000000, -0.490000), vec3(-0.140000, 0.000000, -0.670000), vec3(0.040000, 0.000000, -0.090000), vec3(-0.240000, 1.980000, 0.160000), vec3(-0.240000, 1.980000, -0.220000), vec3(0.230000, 1.980000, 0.160000), vec3(0.230000, 1.980000, -0.220000));\n\nvec3 albedos[36] = vec3[36](vec3(0.725000, 0.710000, 0.680000), vec3(0.725000, 0.710000, 0.680000), vec3(0.725000, 0.710000, 0.680000), vec3(0.725000, 0.710000, 0.680000), vec3(0.725000, 0.710000, 0.680000), vec3(0.725000, 0.710000, 0.680000), vec3(0.725000, 0.710000, 0.680000), vec3(0.725000, 0.710000, 0.680000), vec3(0.140000, 0.450000, 0.091000), vec3(0.140000, 0.450000, 0.091000), vec3(0.140000, 0.450000, 0.091000), vec3(0.140000, 0.450000, 0.091000), vec3(0.630000, 0.065000, 0.050000), vec3(0.630000, 0.065000, 0.050000), vec3(0.630000, 0.065000, 0.050000), vec3(0.630000, 0.065000, 0.050000), vec3(0.725000, 0.710000, 0.680000), vec3(0.725000, 0.710000, 0.680000), vec3(0.725000, 0.710000, 0.680000), vec3(0.725000, 0.710000, 0.680000), vec3(0.725000, 0.710000, 0.680000), vec3(0.725000, 0.710000, 0.680000), vec3(0.725000, 0.710000, 0.680000), vec3(0.725000, 0.710000, 0.680000), vec3(0.725000, 0.710000, 0.680000), vec3(0.725000, 0.710000, 0.680000), vec3(0.725000, 0.710000, 0.680000), vec3(0.725000, 0.710000, 0.680000), vec3(0.725000, 0.710000, 0.680000), vec3(0.725000, 0.710000, 0.680000), vec3(0.725000, 0.710000, 0.680000), vec3(0.725000, 0.710000, 0.680000), vec3(0.780000, 0.780000, 0.780000), vec3(0.780000, 0.780000, 0.780000), vec3(0.780000, 0.780000, 0.780000), vec3(0.780000, 0.780000, 0.780000));\n\nmat3 create_tangent_space(vec3 normal)\n{\n    const float one_over_sqrt_3 = 1.0 / sqrt(3.0);\n    vec3 major;\n    if(abs(normal.x) < one_over_sqrt_3) major = vec3(1,0,0);\n    else if(abs(normal.y) < one_over_sqrt_3) major = vec3(0,1,0);\n    else major = vec3(0,0,1);\n\n    vec3 tangent = normalize(cross(normal, major));\n    vec3 bitangent = cross(normal, tangent);\n\n    return mat3(tangent, bitangent, normal);\n}\n\nuvec4 pcg4d(inout uvec4 seed)\n{\n    seed = seed * 1664525u + 1013904223u;\n    seed += seed.yzxy * seed.wxyz;\n    seed = (seed >> 16) ^ seed;\n    seed += seed.yzxy * seed.wxyz;\n    return seed;\n}\n\nvec3 toSRGB(vec3 c)   { return pow(c, vec3(1.0 / 2.2)); }\n\nbool intersect_scene(\n    vec3 ray_origin,\n    vec3 ray_direction,\n    out vec3 hit_normal,\n    out int hit_object_index,\n    out float hit_t\n){\n    hit_t = 1e20;\n    hit_object_index = -1;\n    hit_normal = vec3(0.0);\n\n    // Loop through all triangles\n    for (int i=0; i < indices.length(); i += 3){\n            \n            \n        //Multiply each vertex with the TRS-matrix\n        vec3 v0 = vec3(positions[indices[i + 0]]);\n        vec3 v1 = vec3(positions[indices[i + 1]]);\n        vec3 v2 = vec3(positions[indices[i + 2]]);\n\n\n        // e1 = v1-v0 and e2 = v2-v0\n        vec3 N = normalize(cross(v1-v0,v2-v0));\n\n        // N * P = D\n        // D = N * P\n        float D = dot(N, v0);\n\n        // N * P = D and P = origin + t*direction\n        // N * (origin + t*direction) = D\n        // N * origin + N * t*direction = D\n        // t = (D - N * origin) / N * direction\n\n        if (abs(dot(N, ray_direction)) > 1e-06) {\n            float t = (D-dot(N, ray_origin)) / dot(N, ray_direction);\n\n            if (t > 0.0 && t < hit_t){\n                vec3 P = ray_origin + t*ray_direction;\n\n                // From v0->v1->v2->v0\n                vec3 posEdge1 = cross(v1-v0,P-v0);\n                vec3 posEdge2 = cross(v2-v1,P-v1);\n                vec3 posEdge3 = cross(v0-v2,P-v2);\n\n                if (dot(posEdge1,N) >= 0.0 && dot(posEdge2,N) >= 0.0 && dot(posEdge3,N) >= 0.0){\n\n                    hit_t = t;\n                    hit_normal = N;\n                    hit_object_index = i / 3; // triangle index\n                }\n            }\n        }\n    }\n    return hit_object_index != -1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / (iResolution.y);\n\n    vec3 cameraOrigin = vec3(0.01, 1.01, 3.01);\n    \n    float radfov = (55.0 / 2.0) * PI / 180.0;\n    float focalLength = 1.0 / tan(radfov);\n    \n    vec3 direction = normalize(vec3(uv, -0.5*focalLength));\n\n    vec3 planeColor = vec3(0.0, 0.0, 0.0);\n    float tMin = 1e20; // Closest hit\n    \n    vec3 hitNormal;\n    int hitObj;\n    float hitT;\n\n    if (!intersect_scene(cameraOrigin, direction, hitNormal, hitObj, hitT)) {\n        // No hit = background\n        planeColor = vec3(0.0);\n        return;\n    }\n    \n    vec3 P = cameraOrigin + hitT * direction;\n    \n    uvec4 seed = uvec4(fragCoord.xy, iFrame, 146);\n    vec4 rng = vec4(pcg4d(seed)) / vec4(0xFFFFFFFFu);\n    vec3 randomVec = vec3( \n        sqrt(1.0-pow(rng.x,2.0))*cos(2.0*PI*rng.y),\n        sqrt(1.0-pow(rng.x,2.0))*sin(2.0*PI*rng.y),\n        rng.x\n    );\n    \n    mat3 tangent = create_tangent_space(hitNormal);\n    vec3 dirWorld = tangent * randomVec;\n    \n    vec3 offset = P + 0.001 * hitNormal;\n    \n    vec3 sh_normal;\n    int sh_obj;\n    float sh_t;\n    \n    if (intersect_scene(offset, dirWorld, sh_normal, sh_obj, sh_t)) {\n        // hit = background black\n        planeColor = vec3(0.0);\n    }else{\n        planeColor = vec3(1.0);\n    }\n    \n    planeColor = toSRGB(planeColor);\n    \n    // Output to screen\n    fragColor = vec4(planeColor,1.0);\n}",
   "name": "Image",
   "description": "",
   "type": "image"
  }
 ]
}