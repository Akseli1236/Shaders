{
 "ver": "0.1",
 "info": {
  "id": "wXSBWV",
  "date": "0",
  "viewed": 0,
  "name": "Ex6, Task 1",
  "description": "tag",
  "likes": 0,
  "published": "Private",
  "usePreview": 0,
  "tags": [
   "tag"
  ],
  "hasliked": 0,
  "parentid": "",
  "parentname": ""
 },
 "renderpass": [
  {
   "inputs": [],
   "outputs": [
    {
     "id": "4dfGRr",
     "channel": 0
    }
   ],
   "code": "#define PI 3.14159265359\n\nint indices[30] = int[30](0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 0, 15, 1, 3, 16, 4, 6, 17, 7, 9, 18, 10, 12, 19, 13);\n\nvec3 positions[20] = vec3[20](vec3(-1.000000, 2.000000, 1.000000), vec3(-1.000000, 0.000000, -1.000000), vec3(-1.000000, 0.000000, 1.000000), vec3(-1.000000, 2.000000, -1.000000), vec3(1.000000, 0.000000, -1.000000), vec3(-1.000000, 0.000000, -1.000000), vec3(1.000000, 2.000000, -1.000000), vec3(1.000000, 0.000000, 1.000000), vec3(1.000000, 0.000000, -1.000000), vec3(1.000000, 2.000000, 1.000000), vec3(-1.000000, 0.000000, 1.000000), vec3(1.000000, 0.000000, 1.000000), vec3(-1.000000, 2.000000, -1.000000), vec3(1.000000, 2.000000, 1.000000), vec3(1.000000, 2.000000, -1.000000), vec3(-1.000000, 2.000000, -1.000000), vec3(1.000000, 2.000000, -1.000000), vec3(1.000000, 2.000000, 1.000000), vec3(-1.000000, 2.000000, 1.000000), vec3(-1.000000, 2.000000, 1.000000));\n\nmat4 translate(vec3 t) {\n    return mat4(\n        1,0,0,0,\n        0,1,0,0,\n        0,0,1,0,\n        t.x, t.y, t.z, 1\n    );\n}\n\nmat4 scale(vec3 s) {\n    return mat4(\n        s.x,0,0,0,\n        0,s.y,0,0,\n        0,0,s.z,0,\n        0,0,0,1\n    );\n}\n\nmat4 rotateX(float deg) {\n    float r = radians(deg);\n    float c = cos(r), s = sin(r);\n    return mat4(\n        1,0,0,0,\n        0,c,s,0,\n        0,-s,c,0,\n        0,0,0,1\n    );\n}\nmat4 rotateY(float deg) {\n    float r = radians(deg);\n    float c = cos(r), s = sin(r);\n    return mat4(\n        c,0,-s,0,\n        0,1,0,0,\n        s,0,c,0,\n        0,0,0,1\n    );\n}\nmat4 rotateZ(float deg) {\n    float r = radians(deg);\n    float c = cos(r), s = sin(r);\n    return mat4(\n        c,s,0,0,\n        -s,c,0,0,\n        0,0,1,0,\n        0,0,0,1\n    );\n}\n\n// Multiply translation matrix, rotation matrices and scale matrix\n// to get transformation matrix\nmat4 makeTRS(vec3 t, vec3 r, vec3 s) {\n    return translate(t) * rotateZ(r.z) * rotateY(r.y) * rotateX(r.x) * scale(s);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / (iResolution.y);\n\n    vec3 cameraOrigin = vec3(0.0, 4.01, 13.5);\n    \n    float radfov = (60.0 / 2.0) * PI / 180.0;\n    float focalLength = 1.0 / tan(radfov);\n    \n    vec3 direction = normalize(vec3(uv, -0.5*focalLength));\n    \n    vec3 position[3] = vec3[3](vec3(2.0, 0.0, 1.0), vec3(-2.0, 0.0, 0.0), vec3(0.0, 4.0, 4.0));\n    vec3 rotation[3] = vec3[3](vec3(0.0, -29.2, 0.0), vec3(0.0, 38.5, 0.0), vec3(-90.0, 0.0, 0.0));\n    vec3 scale[3] = vec3[3](vec3(1.0, 1.0, 1.0), vec3(1.0, 2.0, 1.0), vec3(4.0, 4.0, 4.0));\n    \n\n    vec3 planeColor = vec3(0.0, 0.0, 0.0);\n    float tMin = 1e20; // Closest hit\n    for (int i = 0; i < 3; ++i){\n    \n        mat4 boxTRS = makeTRS(position[i], rotation[i], scale[i]);\n        \n        for (int i=0; i < indices.length(); i += 3){\n            \n            \n            //Multiply each vertex with the TRS-matrix\n            vec3 v0 = (boxTRS * vec4(positions[indices[i + 0]], 1.0)).xyz;\n            vec3 v1 = (boxTRS * vec4(positions[indices[i + 1]], 1.0)).xyz;\n            vec3 v2 = (boxTRS * vec4(positions[indices[i + 2]], 1.0)).xyz;\n\n        \n            // e1 = v1-v0 and e2 = v2-v0\n            vec3 N = normalize(cross(v1-v0,v2-v0));\n\n            // N * P = D\n            // D = N * P\n            float D = dot(N, v0);\n\n            // N * P = D and P = origin + t*direction\n            // N * (origin + t*direction) = D\n            // N * origin + N * t*direction = D\n            // t = (D - N * origin) / N * direction\n\n            if (abs(dot(N, direction)) > 1e-06) {\n                float t = (D-dot(N, cameraOrigin)) / dot(N, direction);\n\n                if (t > 0.0 && t < tMin){\n                    vec3 P = cameraOrigin + t*direction;\n\n                    // From v0->v1->v2->v0\n                    vec3 posEdge1 = cross(v1-v0,P-v0);\n                    vec3 posEdge2 = cross(v2-v1,P-v1);\n                    vec3 posEdge3 = cross(v0-v2,P-v2);\n\n                    if (dot(posEdge1,N) >= 0.0 && dot(posEdge2,N) >= 0.0 && dot(posEdge3,N) >= 0.0){\n\n                        planeColor = N*0.5+0.5;\n                        tMin = t;\n                    }\n                }\n            }\n        }\n    }\n    \n    // Output to screen\n    fragColor = vec4(planeColor,1.0);\n}",
   "name": "Image",
   "description": "",
   "type": "image"
  }
 ]
}