{
 "ver": "0.1",
 "info": {
  "id": "3cKyzz",
  "date": "0",
  "viewed": 0,
  "name": "Ex8, Task 7",
  "description": "tag",
  "likes": 0,
  "published": "Private",
  "usePreview": 0,
  "tags": [
   "tag"
  ],
  "hasliked": 0,
  "parentid": "",
  "parentname": ""
 },
 "renderpass": [
  {
   "inputs": [],
   "outputs": [
    {
     "id": "4dfGRr",
     "channel": 0
    }
   ],
   "code": "#define PI 3.14159265359\n\nvec3 toSRGB(vec3 c)   { return pow(c, vec3(1.0 / 2.2)); }\n\nbool intersect_scene(\n    vec3 ray_origin,\n    vec3 ray_direction,\n    out vec3 hit_normal,\n    out int hit_object_index,\n    out float hit_t\n){\n    \n    hit_t = 1e9;\n    hit_object_index = -1;\n    \n    {\n        vec3 center = vec3(0.0,0.62,-1.92);\n        float radius = 0.62;\n        vec3 oc = ray_origin - center;\n        \n    \n        float a = dot(ray_direction,ray_direction);\n        float b = 2.0 * dot(ray_direction,oc);\n        float c = dot(oc, oc) - radius * radius;\n\n        float discriminant = b*b - 4.0*a*c;\n\n        if (discriminant >= 0.0) {\n\n            //Lower value\n            float t = (-b - sqrt(discriminant)) / (2.0 * a);\n            \n            vec3 p = ray_origin + t * ray_direction;\n        \n            //Normalize aka divide by vectors lenght\n            vec3 n = normalize(p - center);\n            \n            if (t > 0.0 && t < hit_t){\n                hit_t = t;\n                hit_normal = n;\n                hit_object_index = 0;\n            }\n        }\n    }\n    \n    {\n        vec3 normal = vec3(0.0, 1.0, 0.0);\n        \n        if (abs(dot(normal, ray_direction)) > 1e-06) {\n           float t = (-dot(normal, ray_origin)) / dot(normal, ray_direction);\n           \n           if (t > 0.0 && t < hit_t){\n               hit_t = t;\n               hit_normal = normal;\n               hit_object_index = 1;\n           }\n       }\n    }\n    \n    return hit_object_index != -1;\n    \n}\n\nvec2 sample_disk(vec2 rng)\n{\n    float r = sqrt(rng.x);\n    float angle = rng.y * 2.0 * PI;\n    return vec2(r * cos(angle), r * sin(angle));\n}\n\nuvec4 pcg4d(inout uvec4 seed)\n{\n    seed = seed * 1664525u + 1013904223u;\n    seed += seed.yzxy * seed.wxyz;\n    seed = (seed >> 16) ^ seed;\n    seed += seed.yzxy * seed.wxyz;\n    return seed;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / (iResolution.y);\n\n    vec3 cameraOrigin = vec3(0.0,0.62,0.88);\n\n    float radfov = (60.0 / 2.0) * PI / 180.0;\n    float focalLength = 1.0 / tan(radfov);\n    \n    vec3 direction = normalize(vec3(uv, -0.5*focalLength));\n    \n    vec3 planeColor = vec3(0.0, 0.0, 0.0);\n    vec3 sunDirection = vec3(0.6878046006560913, 0.690049317018142, 0.22529263503077648);\n    vec3 sunColor =  vec3(3.0, 3.0, 3.0);\n    vec3 sphereDColor =  vec3(0.87, 0.77, 0.75);\n    vec3 planeDColor = vec3(0.67, 0.3, 0.42);\n    float sphereRoughness = 0.27;\n    float planeRoughness = 0.22;\n    vec3 f0 = vec3(0.04);\n    float disk_radius = 0.1;\n    \n    vec3 normal;\n    int obj;\n    float t;\n    \n    float shadow_sum = 0.0;\n\n    if (intersect_scene(cameraOrigin, direction, normal, obj, t)) {\n        vec3 p = cameraOrigin + t * direction;\n\n        vec3 L = normalize(sunDirection);\n        float NdotL = max(dot(normal, L), 0.0);\n        vec3 V = normalize(cameraOrigin - p);\n        \n        vec3 X = normalize(cross(L, vec3(0.0, 1.0, 0.0)));\n        vec3 Y = normalize(cross(X, L));\n        \n        vec3 halfVector = normalize(L+V);\n        \n        float alpha;\n\n        vec3 color;\n    \n        if (obj == 0) {color = sphereDColor / PI; alpha = sphereRoughness;}\n        if (obj == 1) {color = planeDColor / PI; alpha = planeRoughness;}\n        \n        float my_i = max(0.0,dot(normal,L));\n        float my_o = max(0.0,dot(normal,V));\n        float NdotH = dot(normal, halfVector);\n        \n        float leftSide = my_o * sqrt(pow(alpha,2.0)+my_i*(my_i-pow(alpha,2.0)*my_i));\n        float rightSide = my_i * sqrt(pow(alpha,2.0)+my_o*(my_o-pow(alpha,2.0)*my_o));\n        float alpha2 = pow(alpha,2.0);\n        \n        \n        float G = 0.5 / (leftSide + rightSide);\n        float D = alpha2 / (PI * pow((1.0 + pow(NdotH,2.0)*(alpha2-1.0)),2.0));\n        vec3 F = f0 + (1.0-f0)*pow(1.0-max(0.0,dot(halfVector,L)),5.0);\n        \n        vec3 G_vec3 = vec3(G);\n        vec3 D_vec3 = vec3(D);\n        vec3 fs = F * G * D;\n        vec3 fd = (3.0 - F)*(color / PI);\n        \n        uvec4 seed = uvec4(fragCoord.x, fragCoord.y, 3943, 3246);\n        \n        for (int i = 0; i < 12; ++i){\n\n            vec4 rng = vec4(pcg4d(seed)) / vec4(0xFFFFFFFFu);\n\n            vec2 s = sample_disk(rng.xy) * disk_radius;\n            vec3 shadow_ray_dir = normalize(L + s.x * X + s.y * Y);\n            \n            // Shadow ray offset\n            vec3 offset = p + 0.001 * normal;\n\n            // Trace shadow ray\n            vec3 sh_normal;\n            int sh_obj;\n            float sh_t;\n\n            float visible = 1.0;\n\n            if (intersect_scene(offset, shadow_ray_dir, sh_normal, sh_obj, sh_t))\n            {\n                visible = 0.0;\n            }\n\n            shadow_sum += visible;\n\n        }\n        \n        float shadowFactor = shadow_sum / 12.0;\n\n        planeColor = (fs + fd) * sunColor * NdotL * shadowFactor;\n        \n        \n    }\n    \n    planeColor = toSRGB(planeColor);\n    // Output to screen\n    fragColor = vec4(planeColor,1.0);\n}",
   "name": "Image",
   "description": "",
   "type": "image"
  }
 ]
}