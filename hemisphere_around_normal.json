{
 "ver": "0.1",
 "info": {
  "id": "tcKcRh",
  "date": "0",
  "viewed": 0,
  "name": "Ex9, Task 1",
  "description": "tag",
  "likes": 0,
  "published": "Private",
  "usePreview": 0,
  "tags": [
   "tag"
  ],
  "hasliked": 0,
  "parentid": "",
  "parentname": ""
 },
 "renderpass": [
  {
   "inputs": [],
   "outputs": [
    {
     "id": "4dfGRr",
     "channel": 0
    }
   ],
   "code": "#define PI 3.14159265359\n\nint indices[108] = int[108](0, 1, 2, 1, 3, 2, 4, 5, 6, 5, 7, 6, 2, 3, 7, 2, 7, 5, 8, 9, 10, 9, 11, 10, 12, 13, 14, 12, 14, 15, 16, 17, 18, 17, 19, 18, 20, 18, 21, 18, 19, 21, 22, 16, 20, 16, 18, 20, 23, 17, 22, 17, 16, 22, 21, 19, 23, 19, 17, 23, 23, 17, 22, 17, 16, 22, 24, 25, 26, 25, 27, 26, 28, 24, 29, 24, 26, 29, 29, 26, 30, 26, 27, 30, 30, 27, 31, 27, 25, 31, 31, 25, 28, 25, 24, 28, 31, 25, 28, 25, 24, 28, 32, 33, 34, 33, 35, 34);\n\nvec3 positions[36] = vec3[36](vec3(-1.010000, 0.000000, 0.990000), vec3(1.000000, 0.000000, 0.990000), vec3(-0.990000, 0.000000, -1.040000), vec3(1.000000, 0.000000, -1.040000), vec3(-1.020000, 1.990000, 0.990000), vec3(-1.020000, 1.990000, -1.040000), vec3(1.000000, 1.990000, 0.990000), vec3(1.000000, 1.990000, -1.040000), vec3(1.000000, 0.000000, -1.040000), vec3(1.000000, 0.000000, 0.990000), vec3(1.000000, 1.990000, -1.040000), vec3(1.000000, 1.990000, 0.990000), vec3(-1.010000, 0.000000, 0.990000), vec3(-0.990000, 0.000000, -1.040000), vec3(-1.020000, 1.990000, -1.040000), vec3(-1.020000, 1.990000, 0.990000), vec3(0.530000, 0.600000, 0.750000), vec3(0.700000, 0.600000, 0.170000), vec3(-0.050000, 0.600000, 0.570000), vec3(0.130000, 0.600000, 0.000000), vec3(-0.050000, 0.000000, 0.570000), vec3(0.130000, 0.000000, 0.000000), vec3(0.530000, 0.000000, 0.750000), vec3(0.700000, 0.000000, 0.170000), vec3(-0.530000, 1.200000, 0.090000), vec3(0.040000, 1.200000, -0.090000), vec3(-0.710000, 1.200000, -0.490000), vec3(-0.140000, 1.200000, -0.670000), vec3(-0.530000, 0.000000, 0.090000), vec3(-0.710000, 0.000000, -0.490000), vec3(-0.140000, 0.000000, -0.670000), vec3(0.040000, 0.000000, -0.090000), vec3(-0.240000, 1.980000, 0.160000), vec3(-0.240000, 1.980000, -0.220000), vec3(0.230000, 1.980000, 0.160000), vec3(0.230000, 1.980000, -0.220000));\n\nvec3 albedos[36] = vec3[36](vec3(0.725000, 0.710000, 0.680000), vec3(0.725000, 0.710000, 0.680000), vec3(0.725000, 0.710000, 0.680000), vec3(0.725000, 0.710000, 0.680000), vec3(0.725000, 0.710000, 0.680000), vec3(0.725000, 0.710000, 0.680000), vec3(0.725000, 0.710000, 0.680000), vec3(0.725000, 0.710000, 0.680000), vec3(0.140000, 0.450000, 0.091000), vec3(0.140000, 0.450000, 0.091000), vec3(0.140000, 0.450000, 0.091000), vec3(0.140000, 0.450000, 0.091000), vec3(0.630000, 0.065000, 0.050000), vec3(0.630000, 0.065000, 0.050000), vec3(0.630000, 0.065000, 0.050000), vec3(0.630000, 0.065000, 0.050000), vec3(0.725000, 0.710000, 0.680000), vec3(0.725000, 0.710000, 0.680000), vec3(0.725000, 0.710000, 0.680000), vec3(0.725000, 0.710000, 0.680000), vec3(0.725000, 0.710000, 0.680000), vec3(0.725000, 0.710000, 0.680000), vec3(0.725000, 0.710000, 0.680000), vec3(0.725000, 0.710000, 0.680000), vec3(0.725000, 0.710000, 0.680000), vec3(0.725000, 0.710000, 0.680000), vec3(0.725000, 0.710000, 0.680000), vec3(0.725000, 0.710000, 0.680000), vec3(0.725000, 0.710000, 0.680000), vec3(0.725000, 0.710000, 0.680000), vec3(0.725000, 0.710000, 0.680000), vec3(0.725000, 0.710000, 0.680000), vec3(0.780000, 0.780000, 0.780000), vec3(0.780000, 0.780000, 0.780000), vec3(0.780000, 0.780000, 0.780000), vec3(0.780000, 0.780000, 0.780000));\n\nmat4 translate(vec3 t) {\n    return mat4(\n        1,0,0,0,\n        0,1,0,0,\n        0,0,1,0,\n        t.x, t.y, t.z, 1\n    );\n}\n\nmat4 scale(vec3 s) {\n    return mat4(\n        s.x,0,0,0,\n        0,s.y,0,0,\n        0,0,s.z,0,\n        0,0,0,1\n    );\n}\n\nmat4 rotateX(float deg) {\n    float r = radians(deg);\n    float c = cos(r), s = sin(r);\n    return mat4(\n        1,0,0,0,\n        0,c,s,0,\n        0,-s,c,0,\n        0,0,0,1\n    );\n}\nmat4 rotateY(float deg) {\n    float r = radians(deg);\n    float c = cos(r), s = sin(r);\n    return mat4(\n        c,0,-s,0,\n        0,1,0,0,\n        s,0,c,0,\n        0,0,0,1\n    );\n}\nmat4 rotateZ(float deg) {\n    float r = radians(deg);\n    float c = cos(r), s = sin(r);\n    return mat4(\n        c,s,0,0,\n        -s,c,0,0,\n        0,0,1,0,\n        0,0,0,1\n    );\n}\n\n// Multiply translation matrix, rotation matrices and scale matrix\n// to get transformation matrix\nmat4 makeTRS(vec3 t, vec3 r, vec3 s) {\n    return translate(t) * rotateZ(r.z) * rotateY(r.y) * rotateX(r.x) * scale(s);\n}\n\nmat3 create_tangent_space(vec3 normal)\n{\n    const float one_over_sqrt_3 = 1.0 / sqrt(3.0);\n    vec3 major;\n    if(abs(normal.x) < one_over_sqrt_3) major = vec3(1,0,0);\n    else if(abs(normal.y) < one_over_sqrt_3) major = vec3(0,1,0);\n    else major = vec3(0,0,1);\n\n    vec3 tangent = normalize(cross(normal, major));\n    vec3 bitangent = cross(normal, tangent);\n\n    return mat3(tangent, bitangent, normal);\n}\n\nuvec4 pcg4d(inout uvec4 seed)\n{\n    seed = seed * 1664525u + 1013904223u;\n    seed += seed.yzxy * seed.wxyz;\n    seed = (seed >> 16) ^ seed;\n    seed += seed.yzxy * seed.wxyz;\n    return seed;\n}\n\nvec3 toSRGB(vec3 c)   { return pow(c, vec3(1.0 / 2.2)); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / (iResolution.y);\n\n    vec3 cameraOrigin = vec3(0.01, 1.01, 3.01);\n    \n    float radfov = (55.0 / 2.0) * PI / 180.0;\n    float focalLength = 1.0 / tan(radfov);\n    \n    vec3 direction = normalize(vec3(uv, -0.5*focalLength));\n\n    vec3 planeColor = vec3(0.0, 0.0, 0.0);\n    float tMin = 1e20; // Closest hit\n    \n    for (int i = 0; i < 3; ++i){\n        \n        for (int i=0; i < indices.length(); i += 3){\n            \n            \n            vec3 v0 = vec3(positions[indices[i + 0]]);\n            vec3 v1 = vec3(positions[indices[i + 1]]);\n            vec3 v2 = vec3(positions[indices[i + 2]]);\n\n        \n            // e1 = v1-v0 and e2 = v2-v0\n            vec3 N = normalize(cross(v1-v0,v2-v0));\n\n            // N * P = D\n            // D = N * P\n            float D = dot(N, v0);\n\n            // N * P = D and P = origin + t*direction\n            // N * (origin + t*direction) = D\n            // N * origin + N * t*direction = D\n            // t = (D - N * origin) / N * direction\n\n            if (abs(dot(N, direction)) > 1e-06) {\n                float t = (D-dot(N, cameraOrigin)) / dot(N, direction);\n\n                if (t > 0.0 && t < tMin){                   \n                    vec3 P = cameraOrigin + t*direction;\n                    \n                    uvec4 seed = uvec4(fragCoord.xy, iFrame, 146);\n                    vec4 rng = vec4(pcg4d(seed)) / vec4(0xFFFFFFFFu);\n\n                    vec3 randomVec = vec3(\n                        sqrt(1.0-pow(rng.x,2.0))*cos(2.0*PI*rng.y),\n                        sqrt(1.0-pow(rng.x,2.0))*sin(2.0*PI*rng.y),\n                        rng.x\n                    );\n\n                    mat3 tangent = create_tangent_space(N);\n                    vec3 dirWorld = tangent * randomVec;\n\n                    // From v0->v1->v2->v0\n                    vec3 posEdge1 = cross(v1-v0,P-v0);\n                    vec3 posEdge2 = cross(v2-v1,P-v1);\n                    vec3 posEdge3 = cross(v0-v2,P-v2);\n\n                    if (dot(posEdge1,N) >= 0.0 && dot(posEdge2,N) >= 0.0 && dot(posEdge3,N) >= 0.0){\n\n                        planeColor = dirWorld * 0.5 + 0.5;\n                        tMin = t;\n                    }\n                }\n            }\n        }\n    }\n    \n    if (tMin < 1e20){\n        \n        \n    }\n    \n    planeColor = toSRGB(planeColor);\n    \n    // Output to screen\n    fragColor = vec4(planeColor,1.0);\n}",
   "name": "Image",
   "description": "",
   "type": "image"
  }
 ]
}